import{d as l,w as y}from"./NYkyKxQq.js";import{s as d}from"./CCM_4jRA.js";import{l as h}from"./DOvoZ9Ia.js";const u=y({judges:[],loading:!1,error:null,lastUpdate:null}),a=y({activeCompetition:null,assignedEntries:[],currentEntry:null,judgeId:null,sessionActive:!1,loading:!1,error:null}),S={BJCP_JUDGE:"bjcp_judge",CLUB_JUDGE:"club_judge",GUEST_JUDGE:"guest_judge"};class b{async loadJudges(r){u.update(e=>({...e,loading:!0,error:null}));try{const{data:e,error:t}=await d.from("competition_judges").select(`
          *,
          judge:members!competition_judges_judge_id_fkey(id, name, email, phone),
          competition:competitions(id, name, judging_date)
        `).eq("competition_id",r).order("assigned_at",{ascending:!1});if(t)throw t;return u.update(n=>({...n,judges:e||[],loading:!1,lastUpdate:Date.now()})),e}catch(e){throw console.error("Error loading judges:",e),u.update(t=>({...t,loading:!1,error:e.message})),e}}async assignJudge(r,e){try{const t={competition_id:r,judge_id:e.judge_id,judge_role:e.judge_role||S.CLUB_JUDGE,assignment_notes:e.assignment_notes||null,assigned_at:new Date().toISOString(),assigned_by:e.assigned_by,active:!0},{data:n,error:o}=await d.from("competition_judges").insert([t]).select(`
          *,
          judge:members!competition_judges_judge_id_fkey(id, name, email, phone),
          competition:competitions(id, name, judging_date)
        `).single();if(o)throw o;return u.update(i=>({...i,judges:[...i.judges,n]})),n}catch(t){throw console.error("Error assigning judge:",t),t}}async removeJudge(r){try{const{error:e}=await d.from("competition_judges").update({active:!1,removed_at:new Date().toISOString()}).eq("id",r);if(e)throw e;u.update(t=>({...t,judges:t.judges.filter(n=>n.id!==r)}))}catch(e){throw console.error("Error removing judge:",e),e}}async startJudgingSession(r,e){a.update(t=>({...t,loading:!0,error:null}));try{const{data:t,error:n}=await d.from("competition_judges").select("*").eq("competition_id",r).eq("judge_id",e).eq("active",!0).single();if(n||!t)throw new Error("Judge not assigned to this competition");const{data:o,error:i}=await d.from("competitions").select("*").eq("id",r).single();if(i)throw i;const c=new Date,_=new Date(o.entry_deadline),f=new Date(o.judging_date);if(c<_)throw new Error("Competition entry deadline has not passed yet");const{data:g,error:w}=await d.from("competition_entries").select(`
          *,
          category:bjcp_categories(id, category_name, category_number, subcategory_letter, subcategory_name)
        `).eq("competition_id",r).order("bjcp_category_id",{ascending:!0}).order("entry_number",{ascending:!0});if(w)throw w;const{data:j,error:v}=await d.from("competition_judging_sessions").select("*").eq("competition_id",r).eq("judge_id",e);v&&console.warn("No existing judging sessions found");const E=g.map(m=>{const p=j==null?void 0:j.find(J=>J.entry_id===m.id);return{...m,judging:p||null,hasBeenJudged:!!(p!=null&&p.score)}});return a.update(m=>({...m,activeCompetition:o,assignedEntries:E,judgeId:e,sessionActive:!0,loading:!1,currentEntry:E[0]||null})),{competition:o,entries:E,assignment:t}}catch(t){throw console.error("Error starting judging session:",t),a.update(n=>({...n,loading:!1,error:t.message,sessionActive:!1})),t}}async saveJudgingResults(r,e){try{const t=h(a),n={competition_id:t.activeCompetition.id,entry_id:r,judge_id:t.judgeId,aroma_score:e.aroma_score||null,appearance_score:e.appearance_score||null,flavor_score:e.flavor_score||null,mouthfeel_score:e.mouthfeel_score||null,overall_score:e.overall_score||null,judge_notes:e.judge_notes||null,private_notes:e.private_notes||null,scoresheet_data:e.scoresheet_data||null,judged_at:new Date().toISOString(),updated_at:new Date().toISOString()},{data:o}=await d.from("competition_judging_sessions").select("id").eq("competition_id",t.activeCompetition.id).eq("entry_id",r).eq("judge_id",t.judgeId).single();let i;if(o?i=await d.from("competition_judging_sessions").update(n).eq("id",o.id).select().single():i=await d.from("competition_judging_sessions").insert([n]).select().single(),i.error)throw i.error;return a.update(c=>{const _=c.assignedEntries.map(g=>g.id===r?{...g,judging:i.data,hasBeenJudged:!0}:g);let f=c.currentEntry;return c.currentEntry&&c.currentEntry.id===r&&(f=_.find(g=>g.id===r)),{...c,assignedEntries:_,currentEntry:f}}),i.data}catch(t){throw console.error("Error saving judging results:",t),t}}getJudgingProgress(){const r=h(a);if(!r.assignedEntries.length)return{total:0,completed:0,percentage:0};const e=r.assignedEntries.length,t=r.assignedEntries.filter(o=>o.hasBeenJudged).length,n=Math.round(t/e*100);return{total:e,completed:t,percentage:n}}setCurrentEntry(r){a.update(e=>{const t=e.assignedEntries[r]||null;return{...e,currentEntry:t}})}endSession(){a.update(r=>({activeCompetition:null,assignedEntries:[],currentEntry:null,judgeId:null,sessionActive:!1,loading:!1,error:null}))}clearError(){u.update(r=>({...r,error:null})),a.update(r=>({...r,error:null}))}}const B=new b,G=l(u,s=>s.judges),A=l(u,s=>s.loading),D=l(u,s=>s.error),L=l(a,s=>s),O=l(a,s=>s.sessionActive),k=l(a,s=>s.currentEntry);export{S as J,L as a,k as b,B as c,A as d,D as e,O as i,G as j};
